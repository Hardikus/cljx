(ns scratch
  (:use [cljx.rules :only [cljs-rules]]
        [clojure.java.io :only [reader make-parents]]
        :reload-all)
  (:require [clojure.string :as string]
            [clojure.core.logic :as logic]
            kibit.check
            cljx.core :reload-all)
  (:import [java.io File]))


(def cljx-path "test/cljx")
(def clj-output-path "test/generated/clj")
(def cljs-output-path "test/generated/cljs")

;;Taken from clojure.tools.namespace
(defn cljx-source-file?
  "Returns true if file is a normal file with a .cljx extension."
  [^File file]
  (and (.isFile file)
       (.endsWith (.getName file) ".cljx")))

(defn find-cljx-sources-in-dir
  "Searches recursively under dir for CLJX files.
Returns a sequence of File objects, in breadth-first sort order."
  [^File dir]
  ;; Use sort by absolute path to get breadth-first search.
  (sort-by #(.getAbsolutePath ^File %)
           (filter cljx-source-file? (file-seq dir))))


(defn munge-forms
  [reader rules]
  (->> (kibit.check/check-toplevel-forms reader rules)
       (map #(or (:alt %) (:expr %)))
       (remove #(= % :cljx.core/exclude))))

(defn generate
  ([cljx-path output-path extension]
     (generate cljx-path output-path "cljs"
               (mapcat logic/prep [cljs-rules])))

  ([cljx-path output-path extension rules]
     (doseq [f (find-cljx-sources-in-dir (File. cljx-path))]

       (let [munged-forms (munge-forms (reader f) rules)
             generated-f  (File. (-> (.getPath f)
                                     (string/replace cljx-path output-path)
                                     (string/replace #"cljx$" extension)))]

         (make-parents generated-f)
         (spit generated-f
               (str ";;This file autogenerated from \n;;\n;;  " (.getPath f) "\n;;\n"
                    (string/join "\n" munged-forms)))))))





(comment

  (generate cljx-path cljs-output-path "cljs")


  (defn ns->cljs-ns
    "Creates a cljs-compatible namespace form by splitting vars marked with ^:macro into appropriate use-macros or require-macros forms"
    [ns-form]

    (let [use-forms]

      )

    )

  (def ns-form '(ns
                    (:use [my-ns.thing :only [a b c ^:macro a-macro]]))

    )

  (require '[clojure.core.logic :as logic])

  (use '[kibit.rules.util :only [defrules]]
       '[clojure.core.logic :only [run* fresh matche == != membero]])

  (kibit.core/simplify (quote ^:cljs (ns test.core
                                       (:use-macros [clojure.pprint :only [pp]])))
                       (mapcat logic/prep [cljs-rules]))
  
  
  (let [test1 '(reify
                 Prot1
                 (methodA [_ x] x)

                 Prot2
                 (methodB [_ x] x))]

    (defrules test-rules
      [Prot1 HyphenatedProt]
      [(reify HyphenatedProt (methodA . ?f) . ?rest)
       (reify HyphenatedProt (method-A . ?f) . ?rest)]

      [(reify . ?b Prot2 (methodB . ?f) . ?rest)
       (reify . ?b Prot2 (method-B . ?f) . ?rest)])

))
