(ns scratch
  (:use [cljx.rules :only [cljs-rules]]
        [clojure.java.io :only [make-parents]]
        :reload-all)
  (:require [clojure.string :as string]
            [clojure.core.logic :as logic]
            kibit.check
            cljx.core :reload-all)
  (:import [java.io File]))

;;Taken from clojure.tools.namespace
(defn cljx-source-file?
  "Returns true if file is a normal file with a .cljx extension."
  [^File file]
  (and (.isFile file)
       (.endsWith (.getName file) ".cljx")))

(defn find-cljx-sources-in-dir
  "Searches recursively under dir for CLJX files.
Returns a sequence of File objects, in breadth-first sort order."
  [^File dir]
  ;; Use sort by absolute path to get breadth-first search.
  (sort-by #(.getAbsolutePath ^File %)
           (filter cljx-source-file? (file-seq dir))))



(comment


  (def cljx-path "test/cljx")
  (def clj-output-path "test/generated/clj")
  (def cljs-output-path "test/generated/cljs")



  (doseq [f (find-cljx-sources-in-dir (File. cljx-path))]
    (let [cljs-f  (File. (string/replace (string/replace (.getPath f) cljx-path cljs-output-path)
                                         #"cljx$" "cljs"))]

      (make-parents cljs-f)
      (spit cljs-f
            (with-out-str
              (print ";;This file autogenerated from \n;;\n;;  " (.getPath f) "\n;;\n")
              (kibit/check-file f
                                :rules (mapcat logic/prep [cljs-rules])
                                :reporter (fn [{:keys [line expr alt]}]
                                            (prn alt))
                                )))))

  (use '[kibit.rules.util :only [defrules]])


  (let [test1 '(reify
                 Prot1
                 (methodA [_ x] x)

                 Prot2
                 (methodB [_ x] x))]



    (defrules test-rules
      [Prot1 HyphenatedProt]
      [(reify HyphenatedProt (methodA . ?f) . ?rest)
       (reify HyphenatedProt (method-A . ?f) . ?rest)]

      [(reify . ?b Prot2 (methodB . ?f) . ?rest)
       (reify . ?b Prot2 (method-B . ?f) . ?rest)]
      )

    (kibit.core/simplify test1
                         (mapcat logic/prep [test-rules])))

  )


(logic/run* [q]
            (logic/fresh [pat guards alt]
                         (logic/membero [pat guards alt] [(logic/prep '[(start . ?b thing . ?a)
                                                                        []
                                                                        ?b])])
                         (logic/== q alt) 
                         (logic/== pat )))


(use '[clojure.core.logic :only [run* fresh matche == != membero]])

(run* [q]
  (fresh [a]
         (== a '(start grr grr grr thing meh meh))

    (matche [a]
            ([ [start . ?x . thing . ?rest] ]
             (== q ["two" ?x])))))
